#!/usr/bin/env python

"""
comicthumb - Thumbnailer for comic book archives, bundled with Comix.

comicthumb is dependent on the Python Imaging Library (PIL).

comicthumb was originally written by Christoph Wolk, this version was
re-written from scratch for Comix 4 by Pontus Ekberg. 

Supported formats: ZIP, RAR and tar (.cbz, .cbr, .cbt)

Usage: comicthumb INFILE OUTFILE [SIZE]
"""

import os
import sys
import gc
import re
import cStringIO
import zipfile
import tarfile

try:
    import Image
except ImportError:
    print '! Could not import the Image module (PIL).'
    print __doc__
    sys.exit(1)

class Process:
    
    def __init__(self, args):
        
        """
        Create a Process where <args> is a sequence of arguments that defines
        the process. The first element of <args> shuld be the full path to 
        the executable file to be run.

        This avoids using Python's broken modules "subprocess" et al. (see
        Python issue 1336.)
        """

        self._args = args
        self._pid = None
    
    def spawn(self):
        
        """
        Spawn the process defined by the args in __init__. Return a file-like
        object linked to the spawned process' stdout.
        """

        gc.disable() # Avoid Python issue 1336!
        read_pipe, write_pipe = os.pipe()
        self._pid = os.fork()
        if self._pid == 0:
            try:
                os.close(read_pipe)
                os.dup2(write_pipe, 1)
                os.execv(self._args[0], self._args)
            except:
                sys.stderr.write('Could not execute %s\n' % str(self._args[0]))
                sys.exit(1)
        gc.enable()
        os.close(write_pipe)
        return os.fdopen(read_pipe)

    def wait(self):
        
        """ Wait for the process to terminate. """
        
        if self._pid:
            os.waitpid(self._pid, 0)
        else:
            raise Exception, 'Process not spawned'


class Extractor:
    
    """
    Extractor is a class for extracting different archive formats.
    This is a much simplified version of the Extractor class from Comix.
    """
    
    def __init__(self, src):
        
        """ Setup the extractor with archive <src>. """

        self._src = src
        self._type = archive_mime_type(src)
        self._files = []
        
        if self._type == 'zip':
            self._zfile = zipfile.ZipFile(src, 'r')
            self._files = self._zfile.namelist()
        elif self._type in ['tar', 'gzip', 'bzip2']:
            self._tfile = tarfile.open(src, 'r')
            self._files = self._tfile.getnames()
        elif self._type == 'rar':
            self._rar = None
            for path in os.getenv('PATH', '').split(':'):
                if os.path.isfile(os.path.join(path, 'unrar')):
                    self._rar = os.path.join(path, 'unrar')
                    break
                elif os.path.isfile(os.path.join(path, 'rar')):
                    self._rar = os.path.join(path, 'rar')
                    break
            if self._rar == None:
                print '! Could not find the "rar" or "unrar" executable.'
                sys.exit(1)
            proc = Process([self._rar, 'vb', src])
            fobj = proc.spawn()
            self._files = fobj.readlines()
            proc.wait()
            self._files = [name.rstrip('\n') for name in self._files]
    
    def get_files(self):

        """ Return a list of the files in the archive. """

        return self._files
        
    def extract(self, chosen):
        
        """
        Extract the file <chosen> and return it as a cStringIO.StringIO
        object. The <chosen> file must be one of the files in the list
        returned by the get_files() method.
        """

        if self._type == 'zip':
            return cStringIO.StringIO(self._zfile.read(chosen))
        elif self._type in ['tar', 'gzip', 'bzip2']:
            return cStringIO.StringIO(self._tfile.extractfile(chosen).read())
        elif self._type == 'rar':
            proc = Process([self._rar, 'p', '-n' + chosen, '-inul',
                '-p-', '--', self._src])
            fobj = proc.spawn()
            return cStringIO.StringIO(fobj.read())

def archive_mime_type(path):
    
    """ Return the archive type of <path>. """
    
    try:
        if os.path.isfile(path):
            if zipfile.is_zipfile(path):
                return 'zip'
            if tarfile.is_tarfile(path):
                return 'tar'
            fd = open(path, 'rb')
            magic = fd.read(4)
            fd.close()
            if magic == 'Rar!':
                return 'rar'
    except:
        print '! Error while reading "%s"' % path
    print '! "%s" is not an archive.' % path
    sys.exit(1)
        
def guess_cover(files):
    
    """
    Return the filename within <files> that is the most likely to be the
    cover of an archive.
    """
    
    files.sort()
    ext_re = re.compile(r'\.(jpg|jpeg|png|gif|tif|tiff)\s*$', re.I)
    front_re = re.compile('(cover|front)', re.I)
    images = filter(ext_re.search, files)
    candidates = filter(front_re.search, images)
    candidates = [c for c in candidates if not 'back' in c.lower()]
    if candidates:
        return candidates[0]
    if images:
        return images[0]
    return None

if __name__ == '__main__':
    try:
        in_path = sys.argv[1]
        out_path = sys.argv[2]
        if len(sys.argv) == 4:
            size = int(sys.argv[3])
        else:
            size = 128
    except:
        print __doc__
        sys.exit(1)
    extractor = Extractor(in_path)
    files = extractor.get_files()
    chosen = guess_cover(files)
    fd = extractor.extract(chosen)
    im = Image.open(fd)
    if im.size[0] > im.size[1]:
        x = size
        y = size * im.size[1] / im.size[0]
    else:
        x = size * im.size[0] / im.size[1]
        y = size
    x = max(1, x)
    y = max(1, y)
    im.thumbnail((x, y), Image.ANTIALIAS)
    im = im.convert('RGB')
    im.save(out_path, 'PNG')
    sys.exit(0)

